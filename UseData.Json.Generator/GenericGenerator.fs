module GenericGenerator

open System

open FSharp.Compiler.CodeAnalysis
open FSharp.Compiler.Syntax
open FSharp.Compiler.Text

let run
    (sourceText : ISourceText)
    (outputLine : string -> unit)
    (processTypeDeclaration : ISourceText -> (string -> unit) -> int -> int -> bool) =

    let mutable changed = false
    let mutable directiveLine = -1
    let mutable directiveIndent = -1
    let mutable typeDeclarationLine = -1  // Starts either with `type` or `and` keyword.
    let mutable typeDeclarationLastLine = -1  // Last non-blank line.
    let mutable i = 0

    while i < sourceText.GetLineCount() do
        let line = sourceText.GetLineString i
        let trimmed = line.TrimStart()
        let indent = line.Length - trimmed.Length
        let mutable typeDeclarationEnded = false

        if directiveLine = -1 then
            if trimmed.StartsWith "//" then
                let content = (trimmed.Substring 2).Trim()
                if content = "::UseData.Json.Generator::" then
                    directiveLine <- i
                    directiveIndent <- indent
                    printfn "Found directive on line %d" (directiveLine + 1)
        elif typeDeclarationLine = -1 then
            // Directive can be only followed by attributes.
            if trimmed = "" then
                failwithf
                    "Problem on line %d: Directive on line %d must not be followed by blank line"
                    (i + 1) (directiveLine + 1)
            if indent <> directiveIndent then
                failwithf
                    "Problem on line %d: Directive on line %d must be followed by lines with same indentation"
                    (i + 1) (directiveLine + 1)
            if trimmed.StartsWith "[<" then
                ()  // Attributes are allowed.
            if trimmed.StartsWith "type " || trimmed.StartsWith "and " then
                typeDeclarationLine <- i
                typeDeclarationLastLine <- i
        // We found both directive and type declaration.
        else
            if trimmed = "" then
                // Current blank will be part of type only if it's followed by a non-blank line.
                ()
            elif indent > directiveIndent then
                // Current non-blank line is part of type.
                typeDeclarationLastLine <- i
            else
                typeDeclarationEnded <- true
                // Blank lines at the end of type are not part of type and we will process them again.
                i <- typeDeclarationLastLine + 1
                changed <- processTypeDeclaration sourceText outputLine typeDeclarationLine i || changed

        // Lines of type declarations are processed and outputted by another function after type declaration ends.
        // So we must not output them here.
        if typeDeclarationLine = -1 then
            outputLine line

        if typeDeclarationEnded then
            directiveLine <- -1
            directiveIndent <- -1
            typeDeclarationLine <- -1
            typeDeclarationLastLine <- -1
            // Don't increment `i`. Current line is not part of type.
            // But another directive can start there, so we have to process it again.
        else
            i <- i + 1

    // Opened directive.
    if directiveLine <> -1 then
        if typeDeclarationLine <> -1 then
            // Blank lines at the end of type are not part of type, and we will process them again.
            i <- typeDeclarationLastLine + 1
            changed <- processTypeDeclaration sourceText outputLine typeDeclarationLine i || changed

            // Process remaining blank lines.
            while i < sourceText.GetLineCount() do
                outputLine (sourceText.GetLineString i)
                i <- i + 1
        else
            failwithf
                "Problem: Directive on line %d must be followed by type declaration but reach end of file"
                (directiveLine + 1)

    changed

let private generatedBegin = "// ::BEGIN:Generated by UseData.Json.Generator::"
let private generatedEnd = "// ::END:Generated by UseData.Json.Generator::"
let processTypeDeclaration
    (generate : ParsedInput -> string array)
    (checker : FSharpChecker)
    (sourceText : ISourceText)
    (outputLine : string -> unit)
    (from : int)
    (toExcl : int) =

    let typeDeclarationStr =
        seq {
            let firstLine = sourceText.GetLineString from
            let firstLineWithoutIndent = firstLine.TrimStart()
            if firstLineWithoutIndent.StartsWith "and " then
                // Replace `and ` by `type `, so type declarations starting with `and `
                // are successfully parsed in isolation.
                let indent = firstLine.Length - firstLineWithoutIndent.Length
                yield firstLine.Substring(0, indent) + "type " + firstLineWithoutIndent.Substring(4)
            else yield firstLine

            // Emit remaining lines unchanged.
            for i = from + 1 to toExcl - 1 do
                yield sourceText.GetLineString i
        }
        |> String.concat "\n"
    let typeDeclarationSourceText = SourceText.ofString typeDeclarationStr

    let ast = Ast.getUntypedTree checker "Temp.fsx" typeDeclarationSourceText
    let indent = (sourceText.GetLineString from).Length - (sourceText.GetLineString from).TrimStart().Length
    let indent = String(' ', indent + 4)
    let generated =
        generate ast
        |> Array.map (fun line -> indent + line)

    // Find existing generated code.
    let mutable existingBegin = -1
    let mutable existingEnd = -1
    let mutable i = from + 1  // Generated code can't begin on the same line as type declaration.
    while i < toExcl && existingEnd = -1 do
        let line = sourceText.GetLineString i
        let trimmed = line.Trim()

        if existingBegin = -1 then
            if trimmed = generatedBegin then
                existingBegin <- i
        elif existingEnd = -1 then
            if trimmed = generatedEnd then
                existingEnd <- i

        i <- i + 1

    if existingBegin <> -1 && existingEnd = -1 then
        failwithf
            "Problem: Code generated for type declaration at %d begins at %d but doesn't end"
            (from + 1) (existingBegin + 1)

    // There's no existing generated code - we append it to the end of type declaration.
    if existingBegin = -1 then
        for i = from to toExcl - 1 do
            outputLine (sourceText.GetLineString i)
        outputLine ""
        outputLine (indent + generatedBegin)
        generated |> Array.iter outputLine
        outputLine (indent + generatedEnd)
        true
    else
        let existingGenerated =
            seq { for i = existingBegin + 1 to existingEnd - 1 do sourceText.GetLineString i }
            |> Array.ofSeq
        // Existing generated code is same as newly generated code.
        if existingGenerated = generated then
            for i = from to toExcl - 1 do
                outputLine (sourceText.GetLineString i)
            false
        // Existing generated code is different from newly generated code.
        // We have to replace existing generated code.
        else
            for i = from to existingBegin - 1 do
                outputLine (sourceText.GetLineString i)
            outputLine (indent + generatedBegin)
            generated |> Array.iter outputLine
            outputLine (indent + generatedEnd)
            for i = existingEnd + 1 to toExcl - 1 do
                outputLine (sourceText.GetLineString i)
            true
