module GenericGeneratorTest

open System

open FSharp.Compiler.CodeAnalysis
open FSharp.Compiler.Text
open NUnit.Framework

module Utils =
    let private processTypeDeclaration
        (sourceText : ISourceText)
        (outputLine : string -> unit)
        (from : int)
        (toExcl : int) =

        let checker = FSharpChecker.Create()
        let generate ast =
            let formatTypeVars = function
                | [] -> ""
                | vs -> "<" + String.concat ", " vs + ">"
            let formatType = function
                | Ast.JIdent longIdent -> longIdent |> String.concat "."
                | Ast.JVar v -> v
                | tpe -> failwithf "Unsupported type in these tests: %A" tpe
            match Ast.extractTypeInfo ast with
            | Ast.Union (name, typeVars, cases) ->
                let cases =
                    cases
                    |> Seq.map (fun case ->
                        match case.Types with
                        | [] -> case.Name
                        | types ->
                            types
                            |> List.map formatType
                            |> String.concat " * "
                            |> fun types -> $"%s{case.Name} of %s{types}")
                    |> String.concat ", "
                [| $"// Type name: %s{name}%s{formatTypeVars typeVars}, cases: %s{cases}" |]
            | Ast.Record (name, typeVars, fields) ->
                let fields =
                    fields
                    |> List.map (fun f -> $"%s{f.Name} : %s{formatType f.Type}")
                    |> String.concat ", "
                [| $"// Type name: %s{name}%s{formatTypeVars typeVars}, fields: %s{fields}" |]
        GenericGenerator.processTypeDeclaration generate checker sourceText outputLine from toExcl

    let generate (input : string) : {| Output : string; Changed : bool |} =
        let output = ResizeArray<string>()
        let sourceText = SourceText.ofString input
        let changed = GenericGenerator.run sourceText output.Add processTypeDeclaration
        {| Changed = changed; Output = String.concat "\n" output |}

let ``input - without directive, without generated source`` = """
type Hello =
    { Foo : int
      Bar : string }
"""

[<Test>]
let ``test generator - without directive, without generated source`` () =
    let result = Utils.generate ``input - without directive, without generated source``
    Assert.That(result.Changed, Is.False)
    Assert.That(result.Output, Is.EqualTo(``input - without directive, without generated source``))

let ``input - without directive, with obsolete generated source`` = """
type Hello =
    { Foo : int
      Bar : string }

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Something obsolete.
    // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - without directive, with obsolete generated source`` () =
    let result = Utils.generate ``input - without directive, with obsolete generated source``
    // Obsolete generated source is not touched because there's no directive.
    Assert.That(result.Changed, Is.False)
    Assert.That(result.Output, Is.EqualTo(``input - without directive, with obsolete generated source``))

let ``input - with directive, without generated source`` = """
// ::UseData.Json.Generator::
type Hello =
    { Foo : int
      Bar : string }
"""

let ``expected output - with directive, without generated source`` = """
// ::UseData.Json.Generator::
type Hello =
    { Foo : int
      Bar : string }

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Hello, fields: Foo : int, Bar : string
    // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - with directive, without generated source`` () =
    let result = Utils.generate ``input - with directive, without generated source``
    Assert.That(result.Changed, Is.True)
    Assert.That(result.Output, Is.EqualTo(``expected output - with directive, without generated source``))

let ``input - with directive, with obsolete generated source`` = """
// ::UseData.Json.Generator::
type Hello =
    { Foo : int
      Bar : string }


    // ::BEGIN:Generated by UseData.Json.Generator::
    // Obsolete.

    // ::END:Generated by UseData.Json.Generator::
"""

let ``expected output - with directive, with obsolete generated source`` = """
// ::UseData.Json.Generator::
type Hello =
    { Foo : int
      Bar : string }


    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Hello, fields: Foo : int, Bar : string
    // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - with directive, with obsolete generated source`` () =
    let result = Utils.generate ``input - with directive, with obsolete generated source``
    // Obsolete generated source is replaced.
    // But note that 2 blank lines before the generated source are preserved.
    Assert.That(result.Changed, Is.True)
    Assert.That(result.Output, Is.EqualTo(``expected output - with directive, with obsolete generated source``))

let ``input - with directive, with okay generated source`` = """
// ::UseData.Json.Generator::
type Hello =
    { Foo : int
      Bar : string }

        // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Hello, fields: Foo : int, Bar : string
        // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - with directive, with okay generated source`` () =
    let result = Utils.generate ``input - with directive, with okay generated source``
    // Okay generated source is preserved - even the strange indentation of BEGIN - END delimiters.
    Assert.That(result.Changed, Is.False)
    Assert.That(result.Output, Is.EqualTo(``input - with directive, with okay generated source``))

let ``input - with directive, without generated source, with attribute`` = """
// ::UseData.Json.Generator::
[<Struct>]
type Hello =
    { Foo : int
      Bar : string }
"""

let ``expected output - with directive, without generated source, with attribute`` = """
// ::UseData.Json.Generator::
[<Struct>]
type Hello =
    { Foo : int
      Bar : string }

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Hello, fields: Foo : int, Bar : string
    // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - with directive, without generated source, with attribute`` () =
    let result = Utils.generate ``input - with directive, without generated source, with attribute``
    // Attributes below directive are allowed.
    Assert.That(result.Changed, Is.True)
    Assert.That(
        result.Output,
        Is.EqualTo(``expected output - with directive, without generated source, with attribute``))

let ``input - multiple type declarations`` = """
// ::UseData.Json.Generator::
[<Struct>]
type Weight =
    { Weight : int }

    // Record `Weight` is missing generated source.

// ::UseData.Json.Generator::
type Address =
    { Street : string
      ZipCode : string }

    // Record `Address` contains obsolete generated source.

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Something obsolete.
    // Obsolete code shall be replaced.
    // ::END:Generated by UseData.Json.Generator::

    member me.IsEmpty = String.IsNullOrWhiteSpace me.Street && String.IsNullOrWhiteSpace me.ZipCode

// ::UseData.Json.Generator::
type Person =
    { Name : string
      Address : Address
    }

    // Record `Person` contains okay generated source.

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Person, field names: Name, Address
    // ::END:Generated by UseData.Json.Generator::
"""

let ``expected output - multiple type declarations`` = """
// ::UseData.Json.Generator::
[<Struct>]
type Weight =
    { Weight : int }

    // Record `Weight` is missing generated source.

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Weight, fields: Weight : int
    // ::END:Generated by UseData.Json.Generator::

// ::UseData.Json.Generator::
type Address =
    { Street : string
      ZipCode : string }

    // Record `Address` contains obsolete generated source.

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Address, fields: Street : string, ZipCode : string
    // ::END:Generated by UseData.Json.Generator::

    member me.IsEmpty = String.IsNullOrWhiteSpace me.Street && String.IsNullOrWhiteSpace me.ZipCode

// ::UseData.Json.Generator::
type Person =
    { Name : string
      Address : Address
    }

    // Record `Person` contains okay generated source.

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Person, fields: Name : string, Address : Address
    // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - multiple type declarations`` () =
    let result = Utils.generate ``input - multiple type declarations``
    Assert.That(result.Changed, Is.True)
    Assert.That(result.Output, Is.EqualTo(``expected output - multiple type declarations``))

let ``input - union with directive, without generated source`` = """
// ::UseData.Json.Generator::
type List =
    | Empty
    | One of int
    | More of a:int * b:int * List
"""

let ``expected output - union with directive, without generated source`` = """
// ::UseData.Json.Generator::
type List =
    | Empty
    | One of int
    | More of a:int * b:int * List

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: List, cases: Empty, One of int, More of int * int * List
    // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - union with directive, without generated source`` () =
    let result = Utils.generate ``input - union with directive, without generated source``
    Assert.That(result.Changed, Is.True)
    Assert.That(result.Output, Is.EqualTo(``expected output - union with directive, without generated source``))


let ``input - generic record with directive, without generated source`` = """
// ::UseData.Json.Generator::
type KeyValue<'K, 'V> =
    { Key : 'K
      Value : 'V
    }
"""

let ``expected output - generic record with directive, without generated source`` = """
// ::UseData.Json.Generator::
type KeyValue<'K, 'V> =
    { Key : 'K
      Value : 'V
    }

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: KeyValue<K, V>, fields: Key : K, Value : V
    // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - generic record with directive, without generated source`` () =
    let result = Utils.generate ``input - generic record with directive, without generated source``
    Assert.That(result.Changed, Is.True)
    Assert.That(
        result.Output,
        Is.EqualTo ``expected output - generic record with directive, without generated source``)
