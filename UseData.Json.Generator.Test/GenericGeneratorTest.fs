module GenericGeneratorTest

open System

open FSharp.Compiler.CodeAnalysis
open FSharp.Compiler.Text
open NUnit.Framework

module Utils =
    let private processTypeDeclaration
        (sourceText : ISourceText)
        (outputLine : string -> unit)
        (from : int)
        (toExcl : int) =

        let checker = FSharpChecker.Create()
        let generate ast =
            match Ast.extractTypeInfo ast with
            | Ast.Union (name, cases) ->
                let cases =
                    cases
                    |> Seq.map (fun case ->
                        match case.Types with
                        | [] -> case.Name
                        | types ->
                            types
                            |> List.map (function
                                | Ast.JIdent longIdent -> longIdent |> String.concat "."
                                | tpe -> failwithf "Unsupported type: %A" tpe)
                            |> String.concat " * "
                            |> fun types -> $"%s{case.Name} of %s{types}")
                    |> String.concat ", "
                [| $"// Type name: %s{name}, cases: %s{cases}" |]
            | Ast.Record (name, fields) ->
                let fieldNames = fields |> Seq.map _.Name |> String.concat ", "
                [| $"// Type name: %s{name}, field names: %s{fieldNames}" |]
        GenericGenerator.processTypeDeclaration generate checker sourceText outputLine from toExcl

    let generate (input : string) : {| Output : string; Changed : bool |} =
        let output = ResizeArray<string>()
        let sourceText = SourceText.ofString input
        let changed = GenericGenerator.run sourceText output.Add processTypeDeclaration
        {| Changed = changed; Output = String.concat "\n" output |}

let ``input - without directive, without generated source`` = """
type Hello =
    { Foo : int
      Bar : string }
"""

[<Test>]
let ``test generator - without directive, without generated source`` () =
    let result = Utils.generate ``input - without directive, without generated source``
    Assert.That(result.Changed, Is.False)
    Assert.That(result.Output, Is.EqualTo(``input - without directive, without generated source``))

let ``input - without directive, with obsolete generated source`` = """
type Hello =
    { Foo : int
      Bar : string }

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Something obsolete.
    // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - without directive, with obsolete generated source`` () =
    let result = Utils.generate ``input - without directive, with obsolete generated source``
    // Obsolete generated source is not touched because there's no directive.
    Assert.That(result.Changed, Is.False)
    Assert.That(result.Output, Is.EqualTo(``input - without directive, with obsolete generated source``))

let ``input - with directive, without generated source`` = """
// ::UseData.Json.Generator::
type Hello =
    { Foo : int
      Bar : string }
"""

let ``expected output - with directive, without generated source`` = """
// ::UseData.Json.Generator::
type Hello =
    { Foo : int
      Bar : string }

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Hello, field names: Foo, Bar
    // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - with directive, without generated source`` () =
    let result = Utils.generate ``input - with directive, without generated source``
    Assert.That(result.Changed, Is.True)
    Assert.That(result.Output, Is.EqualTo(``expected output - with directive, without generated source``))

let ``input - with directive, with obsolete generated source`` = """
// ::UseData.Json.Generator::
type Hello =
    { Foo : int
      Bar : string }


    // ::BEGIN:Generated by UseData.Json.Generator::
    // Obsolete.

    // ::END:Generated by UseData.Json.Generator::
"""

let ``expected output - with directive, with obsolete generated source`` = """
// ::UseData.Json.Generator::
type Hello =
    { Foo : int
      Bar : string }


    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Hello, field names: Foo, Bar
    // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - with directive, with obsolete generated source`` () =
    let result = Utils.generate ``input - with directive, with obsolete generated source``
    // Obsolete generated source is replaced.
    // But note that 2 blank lines before the generated source are preserved.
    Assert.That(result.Changed, Is.True)
    Assert.That(result.Output, Is.EqualTo(``expected output - with directive, with obsolete generated source``))

let ``input - with directive, with okay generated source`` = """
// ::UseData.Json.Generator::
type Hello =
    { Foo : int
      Bar : string }

        // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Hello, field names: Foo, Bar
        // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - with directive, with okay generated source`` () =
    let result = Utils.generate ``input - with directive, with okay generated source``
    // Okay generated source is preserved - even the strange indentation of BEGIN - END delimiters.
    Assert.That(result.Changed, Is.False)
    Assert.That(result.Output, Is.EqualTo(``input - with directive, with okay generated source``))

let ``input - with directive, without generated source, with attribute`` = """
// ::UseData.Json.Generator::
[<Struct>]
type Hello =
    { Foo : int
      Bar : string }
"""

let ``expected output - with directive, without generated source, with attribute`` = """
// ::UseData.Json.Generator::
[<Struct>]
type Hello =
    { Foo : int
      Bar : string }

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Hello, field names: Foo, Bar
    // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - with directive, without generated source, with attribute`` () =
    let result = Utils.generate ``input - with directive, without generated source, with attribute``
    // Attributes below directive are allowed.
    Assert.That(result.Changed, Is.True)
    Assert.That(
        result.Output,
        Is.EqualTo(``expected output - with directive, without generated source, with attribute``))

let ``input - multiple type declarations`` = """
// ::UseData.Json.Generator::
[<Struct>]
type Weight =
    { Weight : int }

    // Record `Weight` is missing generated source.

// ::UseData.Json.Generator::
type Address =
    { Street : string
      ZipCode : string }

    // Record `Address` contains obsolete generated source.

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Something obsolete.
    // Obsolete code shall be replaced.
    // ::END:Generated by UseData.Json.Generator::

    member me.IsEmpty = String.IsNullOrWhiteSpace me.Street && String.IsNullOrWhiteSpace me.ZipCode

// ::UseData.Json.Generator::
type Person =
    { Name : string
      Address : Address
    }

    // Record `Person` contains okay generated source.

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Person, field names: Name, Address
    // ::END:Generated by UseData.Json.Generator::
"""

let ``expected output - multiple type declarations`` = """
// ::UseData.Json.Generator::
[<Struct>]
type Weight =
    { Weight : int }

    // Record `Weight` is missing generated source.

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Weight, field names: Weight
    // ::END:Generated by UseData.Json.Generator::

// ::UseData.Json.Generator::
type Address =
    { Street : string
      ZipCode : string }

    // Record `Address` contains obsolete generated source.

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Address, field names: Street, ZipCode
    // ::END:Generated by UseData.Json.Generator::

    member me.IsEmpty = String.IsNullOrWhiteSpace me.Street && String.IsNullOrWhiteSpace me.ZipCode

// ::UseData.Json.Generator::
type Person =
    { Name : string
      Address : Address
    }

    // Record `Person` contains okay generated source.

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: Person, field names: Name, Address
    // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - multiple type declarations`` () =
    let result = Utils.generate ``input - multiple type declarations``
    Assert.That(result.Changed, Is.True)
    Assert.That(result.Output, Is.EqualTo(``expected output - multiple type declarations``))

let ``input - union with directive, without generated source`` = """
// ::UseData.Json.Generator::
type List =
    | Empty
    | One of int
    | More of a:int * b:int * List
"""


let ``expected output - union with directive, without generated source`` = """
// ::UseData.Json.Generator::
type List =
    | Empty
    | One of int
    | More of a:int * b:int * List

    // ::BEGIN:Generated by UseData.Json.Generator::
    // Type name: List, cases: Empty, One of int, More of int * int * List
    // ::END:Generated by UseData.Json.Generator::
"""

[<Test>]
let ``test generator - union with directive, without generated source`` () =
    let result = Utils.generate ``input - union with directive, without generated source``
    Assert.That(result.Changed, Is.True)
    Assert.That(result.Output, Is.EqualTo(``expected output - union with directive, without generated source``))
